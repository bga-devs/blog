[ { "title": "Do the undo &amp;mdash; The search for an undo system", "url": "/blog/posts/do-the-undo/", "categories": "Tips", "tags": "back, class, database", "date": "2022-04-27 14:00:00 +0200", "snippet": "Let’s talk about undoing.BGA has anundo systembut it has limitations: You only have one undo. If you have a multi-step action, undoing meansrestarting from the beginning. The undo system saves the whole database and restores everything. So it’simpossible to use when multiple players can do something to the database, whetherin a multipleactiveplayer state — or if your inactive players can set an optionspecific to the table — or anything else that touches the database.This means that you often have to roll your own undo system. One solution iswhat I did for The Isle of Cats:you do your multi-step actions on the client side. This is totally doable with your ownsystem or withsetClientState.And setClientState is often the simplest — and best — choice. Butthis can lead to code duplication between the client side and the server sidesince you must do more on the client side (like validations).So after creating a database layer, I set outto create a reusable, server-side undo system.A simple startLet’s start with a simple game with only one database table, shape, with 3 columns: shape_id is a unique id for the shape. shape_type_id is a number. 0 is a triangle, 1 is a square and 2 is an hexagon. player_id is the player that owns the shape. It’s NULL if the shape is in the general supply.Let’s say that on your turn, you can do something to take the shape. So you need to changeplayer_id from NULL to 1234. To be able to undo that, you could add a new booleancolumn that is TRUE when the row has been modified. This works, but if it’s possible totake more than one shape, you won’t know the order in which the actions where done. Soyou change this new column to an integer to keep the order. This works until you can take the shapeof another player: you must then remember the previous player_id. This reallydoesn’t scale: soon you’ll be taking a copy of the whole database and we’re backto the BGA undo system.Something differentWe really need a different system. Let’s start at the very beginning: somethingthat can do. We’ll assume that we have a databaselayer that return classes for our table:// Free functionfunction getShapeById($shapeId){ $shape = // Get Shape class instance from database layer return $shape;}class PlayerTakeShapeActionCommand{ private $playerId; private $shapeId; public function __construct($playerId, $shapeId) { // You know the drill } public function do() { $shape = getShapeById($this-&amp;gt;shapeId); $shape-&amp;gt;playerId = $this-&amp;gt;playerId; }}// And somewhere in mygame.game.php (so in &quot;class mygame extends Table&quot;):public function playerTakeShape($shapeId){ // Not shown: other validations... $action = new PlayerTakeShapeActionCommand($this-&amp;gt;getActivePlayerId(), $shapeId); $action-&amp;gt;do();}protected function getAllDatas(){ $result = []; $result[&#39;shapes&#39;] = getAllShapes(); // getAllShapes() is left to your imagination return $result;}When a player clicks on a shape and playerTakeShape() is called, this does… nothing. No notifications are sent, so the client doesn’t know something happened. Nothing is saved to the database so the change does not persist.This is great! Great? Yes! You’ll see later why we need something that doesnothing. But for now, we need it to do a bit more: we need the modification tothe shape to persist in memory:// Global$modifiedShapes = [];// Free functionfunction markShapeModified($shape){ global $modifiedShapes; // $shape references a class (so it&#39;s _not_ a copy) $modifiedShapes[$shape-&amp;gt;shapeId] = $shape;}// Free functionfunction getShapeById($shapeId){ global $modifiedShapes; if (array_key_exists($shape-&amp;gt;shapeId, $modifiedShapes)) { return $modifiedShapes[$shape-&amp;gt;shapeId]; } $shape = // Get Shape class instance from database layer return $shape;}class PlayerTakeShapeActionCommand{ // ... public function do() { $shape = getShapeById($this-&amp;gt;shapeId); markShapeModified($shape); $shape-&amp;gt;playerId = $this-&amp;gt;playerId; }}This still does nothing: after the request to the server, what is only in memoryis lost! But if we could save the instance of PlayerTakeShapeActionCommand tothe database and reload it, we could call its do() function. And after thedo(), getShapeById() would always return the modified shape.A detour into serialize-landWith PHP’s ReflectionClass,it’s actually easy to tranform (almost) any class to a string and back: ReflectionClass allows us to loop on all properties and get their names andvalues, even if they are private. If a value is an array or an object, we need to do a recursive call toprocess everything. If its an object, we need to remember the class name to recreate it.// Free functionfunction extractAllPropertyValues($object){ if (is_array($object)) { return array_map(function ($o) { return extractAllPropertyValues($o); }, $object); } else if (!is_object($object)) { return $object; } $allProperties = [ // The name @classId is arbitrary. It&#39;s prefixed with // an @ to avoid collisions with real properties &#39;@classId&#39; =&amp;gt; get_class($object), ]; $reflect = new ReflectionClass(get_class($object)); foreach ($reflect-&amp;gt;getProperties() as $property) { $property-&amp;gt;setAccessible(true); // Bypass private or protected $value = $property-&amp;gt;getValue($object); $allProperties[$property-&amp;gt;getName()] = extractAllPropertyValues($value); } return $allProperties;}This function actually gives us an associative array than can be converted to astring with json_encode(). To recreate the object, we do the samething in reverse.We also need to use ReflectionClass::newInstanceWithoutConstructor to avoid the classconstructor (for which we don’t know the parameters):// Free functionfunction rebuildAllPropertyValues($values){ if (!is_array($values)) { return $values; } if (array_key_exists(&#39;@classId&#39;, $values)) { $reflect = new ReflectionClass($values[&#39;@classId&#39;]); $object = $reflect-&amp;gt;newInstanceWithoutConstructor(); // Like &#39;new&#39; but does not call the constructor unset($values[&#39;@classId&#39;]); foreach ($values as $propertyName =&amp;gt; $value) { $value = rebuildAllPropertyValues($value); $property = $reflect-&amp;gt;getProperty($propertyName); $property-&amp;gt;setAccessible(true); // Bypass private or protected $property-&amp;gt;setValue($object, $value); } return $object; } else { return array_map(function ($value) { return rebuildAllPropertyValues($value); }, $values); }}Again, this requires a call to json_decode($string, true) to convert a stringto an associative array that can be passed to rebuildAllPropertyValues().Back to doingNow that we can tranform our class into a string, we only need a table — let’scall it action_command — with two columns: An autoincrement id, which is the order the actions are inserted A big enough varchar column to store the serialized class.Our game functions now looks like this:// Free functionpublic function saveActionToDatabase($action){ $string = json_encode(extractAllPropertyValues($action)); // Save $string in action_command table}// Free functionpublic function reloadActionsFromDatabase(){ foreach (/*get rows from action_command table*/ as $row) { $action = rebuildAllPropertyValues(json_decode($row-&amp;gt;string_column, true)); // Don&#39;t forget, calling &quot;do()&quot; will fill $modifiedShapes $action-&amp;gt;do(); }}// Somewhere in mygame.game.php (so in &quot;class mygame extends Table&quot;):public function playerTakeShape($shapeId){ reloadActionsFromDatabase(); // Not shown: other validations... $action = new PlayerTakeShapeActionCommand($this-&amp;gt;getActivePlayerId(), $shapeId); $action-&amp;gt;do(); saveActionToDatabase($action);}protected function getAllDatas(){ reloadActionsFromDatabase(); $result = []; // NOTE: getAllShapes() must look in $modifiedShapes for this to work $result[&#39;shapes&#39;] = getAllShapes(); // getAllShapes() is left to your imagination, as long as you imagine the right implementation :)}Suddenly, we can save actions and redo them each time we need it! … But westill need to reload to see the result. We need to integrate notifications intothis. Let’s create a class to help us:class Notifier{ public function notify($notifType, $notifLog, $notifArgs) { // Get a reference to the game class and call notifyAllPlayers }}We can now notify our players:class PlayerTakeShapeActionCommand{ // ... public function do($notifier) { $shape = getShapeById($this-&amp;gt;shapeId); markShapeModified($shape); $shape-&amp;gt;playerId = $this-&amp;gt;playerId; $notifier-&amp;gt;notify( &#39;MOVE_SHAPE_TO_PLAYER&#39;, &#39;Moving!&#39;, [ &#39;playerId&#39; =&amp;gt; $this-&amp;gt;playerId, &#39;shapeId&#39; =&amp;gt; $this-&amp;gt;shapeId, ] ); }}But there’s a problem: we want to send a notification only the first timewe do the action, not when we reload it from the database. Another classto the rescue: just drop notifications when reloading.class ReloadNotifier{ // Yes, a function that does nothing! public function notify($notifType, $notifLog, $notifArgs) { }}// Free functionpublic function reloadActionsFromDatabase(){ $notifier = new ReloadNotifier(); foreach (/*get rows from action_command table*/ as $row) { $action = rebuildAllPropertyValues(json_decode($row-&amp;gt;string_column, true)); $action-&amp;gt;do($notifier); }}But… where’s the undo?Now that we know how to do, let’s undo.Again, if we could convince everyone to just reload the whole page after eachaction, undoing would only requires deleting the last row in theaction_command table. But we need those notifications. So in ourPlayerTakeShapeActionCommand class, we must remember what is needed to undothe action and add a function to send the notification:class PlayerTakeShapeActionCommand{ private $playerId; private $shapeId; // NEW private $previousPlayerId; public function __construct($playerId, $shapeId) { // You know the drill: store $playerId and $shapeId in properties // But leave $previousPlayerId null } public function do($notifier) { $shape = getShapeById($this-&amp;gt;shapeId); // NEW $this-&amp;gt;previousPlayerId = $shape-&amp;gt;playerId; markShapeModified($shape); $shape-&amp;gt;playerId = $this-&amp;gt;playerId; $notifier-&amp;gt;notify( &#39;MOVE_SHAPE_TO_PLAYER&#39;, &#39;Moving!&#39;, [ &#39;playerId&#39; =&amp;gt; $this-&amp;gt;playerId, &#39;shapeId&#39; =&amp;gt; $this-&amp;gt;shapeId, ] ); } // NEW public function undo($notifier) { $notifier-&amp;gt;notify( &#39;MOVE_SHAPE_TO_PLAYER&#39;, &#39;Undoing!&#39;, [ &#39;playerId&#39; =&amp;gt; $this-&amp;gt;previousPlayerId, &#39;shapeId&#39; =&amp;gt; $this-&amp;gt;shapeId, ] ); }}And the implementation of undo is straightforward:// Somewhere in mygame.game.php (so in &quot;class mygame extends Table&quot;):public function undo(){ // Send an error if the action_command table is empty: no actions to undo! $row = // Get last row from from action_command table $action = rebuildAllPropertyValues(json_decode($row-&amp;gt;string_column, true)); $action-&amp;gt;undo(new Notifier()); // Delete $row from action_command table}When the player confirms their actions — or if they are about to do an actionthat cannot be undone — we need to: Load all rows from action_command table and call do(); Save all modified shapes that are in $modifiedShapes array; Delete all rows from the action_command table!That’s it, we’ve done it!A nice side effectOnce you have such a system, something unexpected happens: you know the actionsthat the player did and you can get useful information out of this. This can replacesome clunky globals that you need to keep to remember the state of the game.Here’s a real example. In the game Bärenpark,a player turn is like this: You take a tile from your own supply. You place the tile on your own board. In doing this, you cover some icons. You take tiles from the general supply. The tiles you are allowed to take depends on the covered icons.Normally, to implement this, you need a table or some globals to remember: The tile that is choosen. The icons that are covered. Each time you take a tile from the general supply, you must match it with the covered icons and removethe icon from the list of icons that are still available.But with the information in the action_command table, you can get thisinformation for free.For example, when you choose a tile in step 1, you save theChooseTileActionCommand class with a $shapeId property. When you are in thestate for step 2, you can search the actions for this class and get the selected$shapeId.The same kind of idea works also for step 2 and 3: in the do() function of step 2, you cansave the covered icons in a member array of the class. Once in step 3, you can query thoseicons to get what tile is available.The do() function of the ActionCommand classes is also a great place tovalidate the parameters: is the selected shapeId really a valid shape? If not,just throw an exception to get out of there!More things to think aboutAt this point, you might be convinced that this is a good idea. And I am! But ifyou are about to go with such a system, you still have other important thingsto think about because a lot of things where left out: State and transitions: At some point, you will need an ActionCommand classto do and undo state transitions. This is a good idea but you need to do the transition only in the first do(),just like with notifications. So the Notifier class is a good place to encapsulatethe code that really calls $this-&amp;gt;gamestate-&amp;gt;nextState(). When undoing, you either need to have a valid transition to the previous state,or you need to use the undocumented $this-&amp;gt;gamestate-&amp;gt;jumpToState($stateId) callto got back to the previous state. Grouping ActionCommand: You can split your ActionCommand in smaller, reusableclasses which is great. But if you use more that one ActionCommand in one player action,you will undo only part of the action if your undo only deletes the last rowof the action_command table. So create a GroupActionCommand class: you add yourActionCommand instances to it and save only the GroupActionCommand. The do() ofthis class only needs to loop on the added classes and call their do() functions.The undo is the samething, but you call undo() in reverse order. Upgrading ActionCommand: Once the game is released, you might need to changean ActionCommand class but you will not be able to use BGA’s upgradeTableDb()function. There are a few options: You can create a new class. You leave the ChooseTileActionCommand class likeit is and you create and start using ChooseTileActionCommandVersion2 classinstead. Old games will be able to undo the first class and when they choose a newtile, the new class will be created and saved. You add a new property in your existing class and initialize it in the constructor.When the class is created in your new code, it will have that value. But if it’s readback from the action_command table from a game that started before the new version,the property will be null because it won’t be initialized by rebuildAllPropertyValues().You can then react accordingly. A real implementationThere’s a lot in this post but it’s a real system that works and the gameBärenpark uses it (thegame is in Alpha at the time of writing).If you want to poke around and see the real implementation, seeAction.phpfrom Bärenpark’s library. Here are a few things to know that will help youbrowse all this code: BaseActionRow and BaseActionRowMgr are the base classes for rowsthat are read from database tables but that can also be modified in memoryonly. This replaces the ugly global $modifiedShapes and associated functionsin the example above. BaseActionCommand is a base class for all ActionCommand ActionCommandRow is a row in the action_command table. BaseActionCommandNotifier and all derived classes are the Notifier in the example above. ActionCommandMgr loads, saves and deletes rows from the action_command table. It also callsdo() and undo().You call also look at real ActionCommand classes fromthe game,like ChooseTileFromPlayerSupplyActionCommandwhich is very simple.Finally, you can check the functionchooseTileFromPlayerSupplywhich is called when the player clicks on a shape. The undo system allows thefunction to be very short and easy to read.More featuresOne thing to note is that, in Bärenpark’s implementation, what a player does isprivate to that player until they confirm their turn. This is to allow theplayer to try some tile placements, like you can do inPatchwork or The Isle ofCats.This also allows some weirder things like preparing your next move even if it’snot your turn! For this, the game tracks private states, meaning that allplayers are in the same state for BGA’s framework but the game also has anothertable to track states for each player. The idea of private states was taken fromWelcome to which uses it for amultipleactiveplayer state, but my implementation is pretty similar. Privateparallelstatesbased on Welcome’s implementation are now available in BGA’s framework, but theywork only when multiple players are active.Finally, allowing players to prepare their next turn means that there might beconflicts to resolve. If you are interessted in that, seeActionCommandMgr::getReevaluationArgs() and ActionCommandMgr::reevaluate().I wouldn’t recommend doing something more complicated than undoing theconflicting actions, as trying to fix actions can become complicated very fast.But Bärenpark’s implementation does do a few tricks if you are eager to go downthe rabbit hole.The End!That’s all for now! Until next time, have fun!" }, { "title": "Stuck with Stock?", "url": "/blog/posts/stuck-with-stock/", "categories": "Tips", "tags": "front, css", "date": "2022-04-20 14:00:00 +0200", "snippet": "If you are on the bga-developer discord,you will often see this answer when someone asks aboutStock: Don’t use stock. — Everyone (almost)You might want to use Stock in some special cases but most of the time you canhave more control and use less code with a pure CSS solution. Let’s lookat how we can do that… and more.CSS SpriteLet’s create a CSSsprite,a single image with the 4 (ugly) tiles of our game:A good way to assign the tiles is to use data-attributes:.tile-supply { /* Nothing for now */}.tile { width: 80px; height: 80px; background-image: url(&quot;tiles.png&quot;); background-size: 160px 160px;}.tile[data-tile-id=&quot;1&quot;] { background-position: 0px 0px; }.tile[data-tile-id=&quot;2&quot;] { background-position: -80px 0px; }.tile[data-tile-id=&quot;3&quot;] { background-position: 0px -80px; }.tile[data-tile-id=&quot;4&quot;] { background-position: -80px -80px; }And then we can use the data-tile-id attribute to create tiles:&amp;lt;div class=&quot;tile-supply&quot;&amp;gt; &amp;lt;div class=&quot;tile&quot; data-tile-id=&quot;4&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;tile&quot; data-tile-id=&quot;2&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;tile&quot; data-tile-id=&quot;1&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;tile&quot; data-tile-id=&quot;3&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;It’s not pretty but it works:Flex layoutThe simplest way to have a nicer supply of tiles is to use flex:.tile-supply { display: flex; flex-wrap: wrap;}.tile-supply .tile { margin: 10px;}Or you could display them in a column by adding flex-direction: columnin .tile-supply.You might want to always have the tiles in the same order in the supply.Or maybe they take too much space and you want to stack them. To do thatnicely for both cases, we’ll first talk about var().What is var()?When I saw CSS variables for the first time, I saw this kind of example::root { --primary-color: blue;}.example { color: var(--primary-color);}So all elements with the example class will have blue text. This is veryuseful to avoid duplicating information in the CSS but sinceSCSS can do thesame kind of things, I didn’t think about it for a while.But CSS variables can do so much more: they are inherited, they can beoverridden in a child class or style attribute, and more! The most importantthing to know is that when you write var(), the value will be read from thestyle of the element; if it’s not defined in the style, it will be read fromthe class; if it’s not defined in the class, it will be read from the parent,and so on.Let’s come back to our example. We want our tiles to always be in the sameorder. We already have an id for each tile, so we’ll use it as our order. Sinceattr() can be used to access the value of other attributes, this works:.tile-supply .tile::after { content: attr(data-tile-id); color: white; font-size: 40px;}And so, you might be tempted to write this:.tile-supply .tile { margin: 10px; /* Sorry, this does not work! */ order: attr(data-tile-id);}But it does not work. This is because the order property requires a number butdata attributes are always strings. But CSS variables to the rescue: theyare typed! So this works:.tile[data-tile-id=&quot;1&quot;] { background-position: 0px 0px; /* Added */ --supply-order: 1;}/* And also for ids 2, 3 and 4... */.tile-supply .tile { margin: 10px; /* Now this works! */ order: var(--supply-order);}Stacking tilesFlex is nice if we need to see them all but, in a lot of games, the tiles arestacked. How can we do that? With absolute positioning:.tile-supply .tile { position: absolute; top: 0px; left: 0px;}OK… But the one on top is supposed to be the one with the highest id.Let’s fix that:.tile-supply .tile { position: absolute; z-index: var(--supply-order); top: 0px; left: 0px;}It works but we can’t see that there are multiple tiles on top of each other.To solve that, we can give each tile a slight offset.Calculating with calc()Once you have var(), the calc() function becomes very handy since it allowsus to do calculations with our variables. Just watch your spacing aroundoperators or else calc() will be very confused.Back to our offset:.tile-supply .tile { position: absolute; z-index: var(--supply-order); /* calc() can work with units */ top: calc(10px * (var(--supply-order) - 1)); left: calc(10px * (var(--supply-order) - 1)); /* Not required but nicer! */ box-shadow: 1px 1px 5px 0px black;}The tiles are stacked!Viewing all stacked tilesWe haven’t adressed the issue of the id of the tiles being off center:.tile { width: 80px; height: 80px; background-image: url(&quot;tiles.png&quot;); background-size: 160px 160px; /* New lines: this will affect childs of .tile, so only ::after in our case */ display: flex; justify-content: center; align-items: center;}But now, if the id is an important information, we can’t see itanymore. Since everything is in CSS, we can add a new rule whenwe hover over the tiles to spread them:.tile-supply .tile { position: absolute; z-index: var(--supply-order); top: calc(10px * (var(--supply-order) - 1)); left: calc(10px * (var(--supply-order) - 1)); box-shadow: 1px 1px 5px 0px black; /* New */ transition: left 0.5s ease-in-out, top 0.5s ease-in-out;}/* New */.tile-supply:hover .tile { top: 0px; left: calc(90px * (var(--supply-order) - 1));}Of course, it doesn’t have to be on hover: you can also use a button and add acss class (in javascript) to the .tile-supply element when you click on thebutton.Dynamic CSS variablesOne final thing to show the usefulness of CSS variables.On our supply board, our tiles are now stacked. Let’s say that if the playertakes a tile, it goes in his player supply and it should not be stacked but itshould be placed in a particular order.When creating the tiles in javascript, we can set different CSS variables:createTile(tileId, playerOrder) { const tile = document.createElement(&#39;div&#39;); tile.classList.add(&#39;tile&#39;); tile.dataset.tileId = tileId; tile.style.setProperty(&#39;--supply-order&#39;, tileId); tile.style.setProperty(&#39;--player-order&#39;, playerOrder); return tile;}Note that I prefer to use vanilla javascript to create HTML elements instead ofthis.format_block/dojo.place: string substitution is good for complex HTMLbut harded to read for simple cases.And in your CSS you can use the variables to place the tiles:/* No change here, still using --supply-order */.tile-supply .tile { position: absolute; z-index: var(--supply-order); top: calc(10px * (var(--supply-order) - 1)); left: calc(10px * (var(--supply-order) - 1)); box-shadow: 1px 1px 5px 0px black; transition: left 0.5s ease-in-out, top 0.5s ease-in-out;}/* New */.player-supply { display: flex; flex-wrap: wrap;}/* New */.player-supply .tile { order: var(--player-order);}This way, when moving tiles from the general supply to the player supply, thetiles will automatically be placed perfectly, without having to do anythingspecial in javascript.That’s all for now! Until next time, have fun!" }, { "title": "Getting the database out of the stone age", "url": "/blog/posts/stone-age-db/", "categories": "Tips", "tags": "back, class, database", "date": "2022-04-06 14:00:00 +0200", "snippet": "See what I did there? StoneAge? OK, sorry aboutthat.BGA’s database layer is… old. Writting database requests by hand is tediousand prone to errors.So after developing 2 games on BGA, I understood enoughof the framework to build my own library on top of what is provided.And the first thing on my todo list: a better database layer!Let’s start with a simple table named shape:$this-&amp;gt;getObjectListFromDB( &quot;SELECT shape_id, shape_type_id, player_id FROM shape&quot;); shape_id is a unique id for the shape. shape_type_id is a number. 0 is a triangle, 1 is a square and 2 is an hexagon. player_id is the player that owns the shape. It’s NULL if the shape is in the general supply.We would like to be able to read each rows in a class like this:class Shape{ public $shape_id; public $shape_type_id; public $player_id;}We need to be able to match columns with the class properties and also know which propertyis the primary key of the table. There are many ways to do that but let’s look at annotations.Annotations / AttributesPHP 8 adds attributes (called annotations in other languages) which could be very usefulhere… but right now we are stuck with PHP 7.4. But all is not lost since we can useDoc comments to implement something similar. Our class will look like this:class Shape{ /** @dbcol @dbkey */ public $shape_id; /** @dbcol */ public $shape_type_id; /** @dbcol */ public $player_id;}Note the double stars at the start of the comments: this normally indicates toPHP that this comment should be extracted to generate documentation. But we willuse this to implement annotations. (This is not my idea, there are existinglibraries that do this too.)Here’s how it works:$reflect = new ReflectionClass(Shape::class);foreach ($reflect-&amp;gt;getProperties() as $property) { $name = $property-&amp;gt;getName(); $doc = $property-&amp;gt;getDocComment(); echo(&quot;$name: $doc\\n&quot;);}And the output will look like this:shape_id: /** @dbcol @dbkey */shape_type_id: /** @dbcol */player_id: /** @dbcol */We use PHP’s ReflectionClassto list properties and get their doc comment. This class has other very usefulmethods when you need to inspect the internals of classes.With that, we only need to parse those comments to know which properties aredatabase columns and which are also the primary key(s) of the table. We’ll leavethe parsing out of this blog post, but see the end for a link to the fullimplementation.Generating SELECTGenerating a SELECT is now easy:$dbColumns = implode(&#39;,&#39;, array_map(function ($p) { // We would need to filter to take only the @dbcol annotations return $p-&amp;gt;getName();}, $reflect-&amp;gt;getProperties()));$sql = &quot;SELECT $dbColumns FROM shape&quot;;echo($sql);// Output:// SELECT shape_id,shape_type_id,player_id FROM shapeGenerating UPDATE, INSERT and DELETEGenerating an UPDATE from a Shape instance requires a little helper toproperly format values for SQL:function sqlNullOrValue($value){ if ($value === null) { return &quot;NULL&quot;; } if (is_string($value)) { return &quot;&#39;&quot; . addslashes($value) . &quot;&#39;&quot;; } else if (is_bool($value)) { return ($value ? &quot;1&quot; : &quot;0&quot;); } else { return &quot;$value&quot;; }}With that, we can generate the UPDATE:$row = new Shape();$row-&amp;gt;shape_id = 123;$row-&amp;gt;shape_type_id = 1; // A square!$row-&amp;gt;player_id = null;$dbValues = implode(&#39;, &#39;, array_map(function ($p) use ($row) { // We would need to filter to take only the @dbcol annotations return $p-&amp;gt;getName() . &quot; = &quot; . sqlNullOrValue($p-&amp;gt;getValue($row));}, $reflect-&amp;gt;getProperties()));$dbKeys = implode(&#39; AND &#39;, array_map(function ($p) use ($row) { // We would need to filter to take only the @dbkey annotations return $p-&amp;gt;getName() . &quot; = &quot; . sqlNullOrValue($p-&amp;gt;getValue($row));}, $reflect-&amp;gt;getProperties()));$sql = &quot;UPDATE shape SET $dbValues WHERE $dbKeys&quot;;echo($sql);// Output (if it was properly filtered):// UPDATE shape SET shape_id = 123, shape_type_id = 1, player_id = NULL WHERE shape_id = 123Finally, generating an INSERT or a DELETE is pretty much the same.Wrapping everything in a manager classWe can now take everything a wrap it in a nice class:// APP_DbObject allows us to call BGA database functionsclass RowManager extends APP_DbObject{ // ... private members ... public function __construct(string $tableName, string $baseRowClassName) { // ... keep those parameters in private members ... } public function insertRow($row) { // Generate INSERT and call $this-&amp;gt;DBQuery($sql) } public function updateRow(BaseRow $row) { // Generate UPDATE and call $this-&amp;gt;DBQuery($sql) } public function deleteRow(BaseRow $row) { // Generate DELETE and call $this-&amp;gt;DBQuery($sql) } public function getAllRows() { $sql = // Generate SELECT foreach ($this-&amp;gt;getObjectListFromDB($sql) as $row) { $rowObject = new $this-&amp;gt;baseClassRowName; foreach ($row as $property =&amp;gt; $value) { $rowObject-&amp;gt;$property = $value; } // $rowObject properties are now initialised. Keep all // those objets in an array to return them all. } }}We can use our new manager it like this:$row = new Shape();$row-&amp;gt;shape_id = 123;$row-&amp;gt;shape_type_id = 1; // A square!$row-&amp;gt;player_id = null;$manager = new RowManager(&#39;shape&#39;, Shape::class);$manager-&amp;gt;insertRow($row);$manager-&amp;gt;getAllRows(); // Returns an array of Shape instancesSuccess!… But we can do much better now that we got a working database manager.The case of shape_type_idThe fact that shape_type_id is a integer means that we need to write code like this:class Shape { // ... Properties ... // Not the best example but you get the idea public function countSides() { switch ($this-&amp;gt;shape_type_id) { case 0: return 3; case 1: return 4; case 2: return 6; } throw new BgaSystemException(&quot;Unknown shape_type_id!&quot;); }}This is not very nice, especially if you have multiple functions and you need toadd a new shape type! Let’s try to change how Shape is defined:abstract class Shape{ /** @dbcol @dbkey */ public $shape_id; // NOTE THE CHANGE ON THE NEXT 2 LINES /** @dbcol @dbclassid */ public $class_id; /** @dbcol */ public $player_id; abstract public function countSides();}class Triangle extends Shape{ public function countSides() { return 3; }}class Square extends Shape{ public function countSides() { return 4; }}class Hexagon extends Shape{ public function countSides() { return 6; }}Much better! In the database, class_id must be a (long enough) varchar. But how toget our database manager to understand this?class RowManager extends APP_DbObject{ // No change to constructor public function insertRow($row) { // We must now do this: $propertyClassId = // Get property with @dbclassid, so &#39;class_id&#39; in our case if ($propertyClassId !== null) { // get_class will return the real class as // a string, so &#39;Triangle&#39;, &#39;Square&#39; or &#39;Hexagon&#39; $row-&amp;gt;$propertyClassId = get_class($row); } // Generate INSERT and call $this-&amp;gt;DBQuery($sql) } public function updateRow(BaseRow $row) { // We do the same thing to update the property with @dbclassid // Generate UPDATE and call $this-&amp;gt;DBQuery($sql) } // No change for deleteRow public function getAllRows() { $sql = // Generate SELECT foreach ($this-&amp;gt;getObjectListFromDB($sql) as $row) { $classId = $this-&amp;gt;baseClassRowName; $propertyClassId = // Get property with @dbclassid, so &#39;class_id&#39; in our case if ($propertyClassId !== null) { $classId = $row[$propertyClassId]; } // PHP can create class if you have their name in a string $rowObject = new $classId; foreach ($row as $property =&amp;gt; $value) { $rowObject-&amp;gt;$property = $value; } // $rowObject properties are now initialised. Keep all // those objets in an array to return them all. } }}We can now create shapes and save them:$row1 = new Square();$row1-&amp;gt;shape_id = 123;$row1-&amp;gt;player_id = null;$row2 = new Triangle();$row2-&amp;gt;shape_id = 456;$row2-&amp;gt;player_id = 67890123;$manager = new RowManager(&#39;shape&#39;, Shape::class);$manager-&amp;gt;insertRow($row1);$manager-&amp;gt;insertRow($row2);$manager-&amp;gt;getAllRows(); // Returns [Square, Triangle]Note that unlike real inheritance, all the properties must be in the base classsince we only have one table.And that’s not all!This post is only a part of what you can do! For example, in my implementation,I support the annotation @dbautoincrement to indicate that the column isautoincrement in the database so that the library can read the new value fromthe database when inserting. I also prefer my database columns to be snake_case(like shape_id) while in PHP they are camelCase (like $shapeId) so Ido this conversion too. And so much more!If you want to see more of the database library, you can look at theimplementation inDB.php.The annotation library (and more reflection-related functions) is in anotherfile:Meta.php.Hopefully, next time we’ll talk about what we can build on top of that databasemanager. Until next time, have fun!" }, { "title": "Why (I) use TypeScript", "url": "/blog/posts/why-use-typescript/", "categories": "Tips", "tags": "front, typescript, debug", "date": "2022-03-09 12:00:00 +0100", "snippet": "Using TypeScript on my day-time job, I’m very used to it and I can see the advantages of it. As it is not integrated by default on BGA framework, I made a tutorial to set it up on your projects.I’ll show 2 examples, one using JavaScript, the other using TypeScript. In both cases, I just want to update a counter on the player panel when the player play a card (counter should go from 8 to 7).Here is an example using only JavaScript : At the end, no JS error is visible, but the code doesn’t work. I need to do more debugging, but I skipped that part so the video isn’t too long, but you got it, it’s long and it’s a pain.Here is the example using TypeScript : As you can see, as TypeScript got strong typing check, I can see errors and fix them when I’m writing my code, instead of waiting run-time to see/debug.If you are interested, doc to setup TypeScript is here : https://en.doc.boardgamearena.com/Using_Typescript_and_Scss" }, { "title": "Translations - a recap", "url": "/blog/posts/translations-summary/", "categories": "Guide", "tags": "back, front, translation", "date": "2021-11-28 11:00:00 +0100", "snippet": "As I usually say on the discord server for BGA developpers, translations are easy and hard.Hard because translations seems to be one of the most recurring issue developpers are facing on BGA, even for experienced developpers.And easy because we will see that the basic mechanisms can be summarized in a couple principles.This small guide is not here to replace documentation, please make sure to also check this page:Studio doc for TranslationsMain principlesHere are the two main principles: clienttranslate on the backend is doing nothing, expect marking the string to add it to the translation system _(...) will translate the string given only if this exact string was marked at some pointThese principles are already enough to understand why this example is not working:$a = 2;$msg = clienttranslate(&quot;The dice value is ${a}&quot;)The parsing script will mark the string The dice value is ${a} as translatable, but will be prompted to translate The dice value is 2 which is a different string, so it will fail.So how to deal with dynamic strings like this one with the framework then? Time to talk about the famous format_string_recursive that frighten new devs!format_string_recursive: a first lookLet’s actually have a look at some part of the code of this function, augmented with comments:format_string_recursive: function (log, args) { var text = &#39;&#39;; if (log != &#39;&#39;) { var log = this.clienttranslate_string(log); // TRANSLATION HAPPENS HERE !! if (log === null) { // THE RED BANNER YOU GET IN CASE OF MISSING TRANSLATION this.showMessage(&#39;Missing translation for `&#39; + log + &#39;`&#39;, &#39;error&#39;); console.error(&#39;Missing translation for `&#39; + log + &#39;`&#39;, &#39;error&#39;); return &#39;&#39;; } [1] // that&#39;s for later [2] // and for even later try { // THIS IS WERE SUBSTITUTION TAKES PLACE text = dojo.string.substitute(log, args); } catch (e) { ... // HANDLE ERRORS console.error(&#39;Invalid or missing substitution argument for log message: &#39; + _884, &#39;error&#39;); text = log; } } return text;}This function takes two arguments: the message and the variable that needs to be substituted. It translates the log using clienttranslate_string, which is basically calling _() on it, and then replace variable occurences with their value. So instead of receiving only a message, the framework always deal with pairs (message, arguments) to handle these more complex cases: for notifications, you give first the message, then the arguments, so you would do: self::notifyAllPlayers(&#39;rollDice&#39;, clienttranslate(&#39;The dice value is ${a}&#39;), [&#39;a&#39; =&amp;gt; 2]) for state descriptions, the framework fetch the message from states.inc.php, so you would put &#39;descriptionmyturn&#39; =&amp;gt; clienttranslate(&quot;You must put the number ${a} on your grid&quot;). And then the arguments are just the general args of the states so you would need to add &#39;a&#39; =&amp;gt; 2 in your state args for instance. you can also use this for your own UI elements in front, such as buttons: this.addActionButton(&#39;mybutton&#39;, this.format_string_recursive(_(&#39;Take ${x} wood&#39;), {x : 4}), null, false, &#39;blue&#39;) Translatable argumentsThis is fine until you want for instance a state description that looks like &quot;You must build on ${type}&quot;.Sure, you can put &#39;descriptionmyturn&#39; =&amp;gt; clienttranslate(&#39;You must build on ${type}&#39;) and then adds to your state args &#39;type&#39; =&amp;gt; $type, but how to get the framework to also translate this string (assuming you defined $type with clienttranslate before)?Well the format_string_recursive can already handle that since the [1] omission in the function code looks like this:// CHECK TRANSLATABLE ARGUMENTSif (typeof args.i18n != &#39;undefined&#39;) { for (i in args.i18n) { let key = args.i18n[i]; args[key] = this.clienttranslate_string(args[key]); }}So, as explained in the doc, you only need to add an i18n entry specifying which arguments should also be translated before being substituted in the message. Notice that this is true for any use case of format_string_recursive, so it works with notifications, but also with state args and any user calls in frontend, such as:this.addActionButton(&#39;mybutton&#39;, this.format_string_recursive( _(&#39;Take ${x} ${res}&#39;), { i18n: [&#39;res&#39;] x : 4, res: _(&#39;wood&#39;), }),...);Recursivity kicks inNow let’s say I want to notify the fact that some players earned a bunch of resources : 3 woods, 2 stones, 1 food.My notification message will be something like clienttranslate(&#39;${player_name} gains ${res}&#39;) but since translation is made only in the client, what value should I give to $res in my args to make the framework properly handle that?Let’s look at the [2] omission in the function:// RECURSIVE FORMATINGfor (key in args) { if ((key != &#39;i18n&#39;) &amp;amp;&amp;amp; ((typeof args[key]) == &#39;object&#39;)) { if (args[key] !== null) { if ((typeof args[key].log != &#39;undefined&#39;) &amp;amp;&amp;amp; (typeof args[key].args != &#39;undefined&#39;)) { args[key] = this.format_string_recursive(args[key].log, args[key].args); } } }}That’s the part that justify the function name, and makes it so powerful. So far we were only dealing with strings/number as arguments that were substituted in the message, but if you actually gives an object, the function will apply itself on it, looking at the log and args entries of that object.So our initial issue could be solved by sending this inside the args of the notification:[ &#39;res&#39; =&amp;gt; [ &#39;log&#39; =&amp;gt; clienttranslate(&#39;${nRes1} ${res1}, ${nRes1} ${res1}, ${nRes3} ${res3}&#39;), &#39;args&#39; =&amp;gt; [ &#39;i18n&#39; =&amp;gt; [&#39;res1&#39;, &#39;res2&#39;, &#39;res3&#39;], // CRUCIAL to have the resource types correctly translated &#39;nRes1&#39; =&amp;gt; 3, &#39;res1&#39; =&amp;gt; clienttranslate(&#39;woods&#39;), // probably defined elsewhere in a real game, such as material.inc.php &#39;nRes2&#39; =&amp;gt; 2, &#39;res2&#39; =&amp;gt; clienttranslate(&#39;stones&#39;), &#39;nRes3&#39; =&amp;gt; 1, &#39;res3&#39; =&amp;gt; clienttranslate(&#39;food&#39;) ] ]]This works, but it’s not very dynamic: what if I have 4 resources ? 5 ? Only 2?We can notice that the clienttranslate is not useful here and we can then generate the log dynamically instead$resources = [WOOD =&amp;gt; 3, STONE =&amp;gt; 2, FOOD =&amp;gt; 1];$logs = [];$args = [];$i = 0;foreach($resources as $type =&amp;gt; $amount){ $logs[] = &#39;${nRes&#39;. $i. &#39;} ${res&#39;. $i .&#39;}&#39;; $args[&#39;nRes&#39; . $i] = $amount; $args[&#39;res&#39; . $i] = RESOURCE_NAME[$type]; // constants holding clienttranslated names of resources $args[&#39;i18n&#39;][] = &#39;res&#39; . $i; $i++;}self::notifyAllPlayers(&#39;gainResources&#39;, clienttranslate(&#39;${player_name} gains ${res}&#39;), [ &#39;res&#39; =&amp;gt; [ &#39;log&#39; =&amp;gt; implode(&#39;,&#39;, $logs), &#39;args&#39; =&amp;gt; $args ]]);More recursivityThe good thing about recursivity is that you can go as deep as you want, it will just works the same.So you could do some state description like that for instance:[ &#39;log&#39; =&amp;gt; clienttranslate(&#39;${action1} then ${action2}&#39;), &#39;args&#39; =&amp;gt; [ &#39;action1&#39; =&amp;gt; [ &#39;log&#39; =&amp;gt; clienttranslate(&#39;take ${x} ${type}&#39;), &#39;args&#39; =&amp;gt; [ &#39;x&#39; =&amp;gt; 2, &#39;i18n&#39; =&amp;gt; [&#39;type&#39;], &#39;type&#39; =&amp;gt; clienttranslate(&#39;wood&#39;) ], ], &#39;action2&#39; =&amp;gt; [ &#39;log&#39; =&amp;gt; clienttranslate(&#39;move ${army} ${x} squares&#39;), &#39;args&#39; =&amp;gt; [ &#39;x&#39; =&amp;gt; 3, &#39;army&#39; =&amp;gt; [ &#39;log&#39; =&amp;gt; clienttranslate(&#39;${n1} ${unit1}, ${n2} ${unit2}&#39;), &#39;args&#39; =&amp;gt; [ &#39;i18n&#39; =&amp;gt; [&#39;unit1&#39;, &#39;unit2&#39;], &#39;n1&#39; =&amp;gt; 3, &#39;uni1&#39; =&amp;gt; clienttranslate(&#39;soldiers&#39;), &#39;n2&#39; =&amp;gt; 2, &#39;unit2&#39; =&amp;gt; clienttranslate(&#39;archers&#39;) ] ] ] ] ]]And that’s why I’m saying that translation is easy: you can handle any crazy complex cases with always the same pattern, by always keeping in mind these two simple principles :)." }, { "title": "Quick debug (part 2)", "url": "/blog/posts/quick-debug-part2/", "categories": "Tips", "tags": "front, debug, replay", "date": "2021-11-28 05:30:00 +0100", "snippet": "The post is a follow-up to https://bga-devs.github.io/blog/posts/quick-debug-part1/ and will use the debug methods similar to what was explained on part 1.For this post, I share my experience on game Azul. It can have a lot of tiles on board, and when you want to copy of a game based on a replay, it can be tedious to write tile positions one by one to reproduce the replay configuration.So, the idea was to generate those debug lines based on the replay.As it is similar to debug methods discussed on part 1, I’ll just share debug method signatures I have on Azul : private function debugSetWallTile(int $playerId, int $line, int $column, int $color) { // set a tile on $line/$column coordinate } private function debugSetLineTiles(int $playerId, int $line, int $number, int $color) { // set $number tiles of the same color on $line }For first bugs I filled debugSetup() manually with calls to these methods.For some replays, I had to write more than 30 lines of debug, that’s when I changed my mind and decided to write a little JS tool to “extract” tile positions from replay. So I write this little piece of JS : function getDebugWall(playerId) { for (line = 1; line &amp;lt;= 5; line++) { for (column = 1; column &amp;lt;= 5; column++) { // every wall position is called a spot, wether it is filled by a tile or not const spotId = `player-table-${playerId}-wall-spot-${line}-${column}`; // if there is a tile, we will find a div of class &quot;tile&quot; const tile = Array.from(document.getElementById(spotId).children).find(elem =&amp;gt; elem.classList.contains(&#39;tile&#39;)); if (tile) { // color is the second class, and ends with a digit indicating color const color = tile.classList[1].match(/(\\d)/)[0]; // we generate a debug command console.log(`$this-&amp;gt;debugSetWallTile(${playerId}, ${line}, ${column}, ${color});\\n`); } } } }Then I go to a specific move on the replay, open debug console and paste method on it. Then I just call this from console : // we call declared method just above with a player&#39;s id getDebugWall(84222058)And console will give us the debug lines we can add to debugSetup() method.$this-&amp;gt;debugSetWallTile(84222058, 1, 5, 2);$this-&amp;gt;debugSetWallTile(84222058, 2, 2, 3);$this-&amp;gt;debugSetWallTile(84222058, 2, 3, 4);$this-&amp;gt;debugSetWallTile(84222058, 3, 2, 2);$this-&amp;gt;debugSetWallTile(84222058, 3, 5, 5);$this-&amp;gt;debugSetWallTile(84222058, 4, 2, 1);And we have our debug line, without doing boring repetitive and error-prone task of rewriting the game positions manually !" }, { "title": "Classes, notifications and bugs!", "url": "/blog/posts/class-notif/", "categories": "Tips", "tags": "back, class, notification", "date": "2021-11-25 14:00:00 +0100", "snippet": "When creating a game, you will probably want to create classes so that yourcode doesn’t become a mess. Something like this:class Card{ public $cardId; public $locationId; public $playerId; // ... And lots of other members...}If you need to move a card in the user interface, you can send the carddirectly in a notification:$card = // A function that returns an instance of the Card class$card-&amp;gt;moveToSomewhere(); // Changes $locationId=1 and saves the change in the database$this-&amp;gt;notifyAllPlayers( &#39;move_card&#39;, clienttranslate(&#39;Card is moving somewhere!&#39;), [ &#39;card&#39; =&amp;gt; $card, ]);This works because the card instance is transformed in an associative array: thekeys are the public members and the values are the values of those members. Soin javascript it will look like this:notif_MoveCard(notif) { // Valid members: // notif.arg.card.cardId // notif.arg.card.locationId // notif.arg.card.playerId}This works well but there is a bug lurking in there. While implementing theSolo mode for The Isle of Cats,I suddendly had to do more than one thing with the same card in the same action. Thishappens since the ‘opponent’ is automated. So the code looked something like this:$card = // A function that returns an instance of the Card class$card-&amp;gt;moveToSomewhere(); // Changes $locationId=1 and saves the change in the database$this-&amp;gt;notifyAllPlayers( &#39;move_card&#39;, clienttranslate(&#39;Card is moving somewhere!&#39;), [ &#39;card&#39; =&amp;gt; $card, ]);$card-&amp;gt;moveToSomewhereElse(); // Changes $locationId=2 and saves the change in the database$this-&amp;gt;notifyAllPlayers( &#39;move_card&#39;, clienttranslate(&#39;Card is moving somewhere else!&#39;), [ &#39;card&#39; =&amp;gt; $card, ]);You will receive two notifications in javascript, but both will have locationId == 2.This happens because the same instance of the class is stored with each notificationbut it’s not transformed in an associative array until the end of the processing onthe server, which may span multiple state transitions.This bug can be very hard to spot when the notifications are far apart. Toprevent this, you can force the class to become an array so that you get animmediate copy of the data:$this-&amp;gt;notifyAllPlayers( &#39;move_card&#39;, clienttranslate(&#39;Card is moving somewhere!&#39;), [ &#39;card&#39; =&amp;gt; (array)$card, // Here the (array) cast is added ]);Since this is easy to forget and does not work if your members are instances ofother classes (this is not a deep copy), I’ve created more general functions:private static function toNotifArray($array_or_value){ if (is_array($array_or_value)) { return array_map(function ($v) { return toNotifArray($v); }, $array_or_value); } if (is_object($array_or_value)) { return toNotifArray((array)$array_or_value); } return $array_or_value;}public function gameNotifyAllPlayers($notifType, $notifLog, $notifArgs){ $this-&amp;gt;notifyAllPlayers($notifType, $notifLog, self::toNotifArray($notifArgs));}public function gameNotifyPlayer($playerId, $notifType, $notifLog, $notifArgs){ $this-&amp;gt;notifyPlayer($playerId, $notifType, $notifLog, self::toNotifArray($notifArgs));}So this works with no surprises:$this-&amp;gt;gameNotifyAllPlayers( &#39;move_card&#39;, clienttranslate(&#39;Card is moving somewhere!&#39;), [ &#39;card&#39; =&amp;gt; $card, ]);" }, { "title": "Quick debug (part I)", "url": "/blog/posts/quick-debug-part1/", "categories": "Tips", "tags": "back, debug", "date": "2021-11-24 10:30:00 +0100", "snippet": "For some games, you need to be able to test a particular case quickly. I will detail here how I do it for the game King of Tokyo, who got 66 different cards, and of course a lot more of possible combinations. Playing the game over and over, hoping to get the right combination to test, is impossible.So I needed a way to reproduce particular cases, by forcing some cards where I want them to be.First, I created a method I call “debugSetup” : function debugSetup() { // we will setup the particular case here }this is called at the end of the setupNewGame method. I created this method in a DebugTrait, where I will put other debug related methods.Before putting debug code here, let’s protect it to be sure we don’t put debug code in production : function debugSetup() { if ($this-&amp;gt;getBgaEnvironment() != &#39;studio&#39;) { return; } // we will setup the particular case here }This will prevent our debug code to be executed in production, in case we forgot to comment “debugSetup” call !Then we will create methods to add cards in table or in player hand (I’m using Stock for cards) private function debugSetCardInTable($cardType) { $this-&amp;gt;cards-&amp;gt;moveCard( $this-&amp;gt;getCardFromDb(array_values($this-&amp;gt;cards-&amp;gt;getCardsOfType($cardType))[0])-&amp;gt;id, &#39;table&#39;); } private function debugSetCardInHand($cardType, $playerId) { $card = $this-&amp;gt;getCardFromDb(array_values($this-&amp;gt;cards-&amp;gt;getCardsOfType($cardType))[0]); $this-&amp;gt;cards-&amp;gt;moveCard($card-&amp;gt;id, &#39;hand&#39;, $playerId); return $card; }Then, to add some cards on player’s hand or on table, I just do : function debugSetup() { if ($this-&amp;gt;getBgaEnvironment() != &#39;studio&#39;) { return; } $this-&amp;gt;debugSetCardInTable(JET_FIGHTERS_CARD); $this-&amp;gt;debugSetCardInHand(RAPID_HEALING_CARD, 2343492); $this-&amp;gt;debugSetCardInHand(ACID_ATTACK_CARD, 2343493); }“2343492” being my player0 id, “2343493” for player1.Starting the game with this, will result, in studio, with cards already in hand/table ! Easier to debug them.But we can go a little further. For example, Rapid Healing card can only be used if player got some energy. This is stored as an int column in player table. Let’s add some new debug methods ! private function debugSetPlayerEnergy($playerId, $energy) { self::DbQuery(&quot;UPDATE player SET `player_energy` = $energy where `player_id` = $playerId&quot;); } private function debugSetEnergy($energy) { self::DbQuery(&quot;UPDATE player SET `player_energy` = $energy&quot;); }I can now use $this-&amp;gt;debugSetEnergy(5); to set to all players, or $this-&amp;gt;debugSetPlayerEnergy(2343492, 5); to set to only one player.I made the same for health and points. Ready to test Rapid Healing !Yet… even if I start a 2 player game, sometimes player0 will start, sometimes player1 ! I don’t want to lose the time of a player’s turn before testing, so I add $this-&amp;gt;gamestate-&amp;gt;changeActivePlayer(2343493); at the end of “debugSetup” to force the first player.Another interesting tip is to force the next card to the deck. You can do it by changing order in deck with a high value (more than the card number will do the trick)self::DbQuery(&quot;UPDATE card SET `card_location_arg` = card_location_arg + 1000 where `card_type` = &quot;.ZOMBIE_CARD);That’s it for part 1 ! I hope it will give you some new tips to debug quickly your game !" }, { "title": "How to make a real fast replay mode", "url": "/blog/posts/a-real-fast-replay-mode/", "categories": "Tips", "tags": "replay, front", "date": "2021-11-18 16:33:00 +0100", "snippet": "This is the story of how I went from this (~1min for 80 replayed moves) :to this (~8sec) :Before diving into code, maybe you are asking yourself:Well, when you have a bug report at move 450 that needs more than 8min to reach, you start wondering why is fast mode not that fast :)Fast replay modeSome players don’t know that feature, but once you enter a replay, you have access to a fast replay mode under the “advanced settings” link:(let’s not get distracted by the fact that the link is translated while the menu is not…)But what is this fast mode doing exactly? Diving into BGA framework’s code, we can find this:setModeInstataneous: function () { if (this.instantaneousMode == false) { this.instantaneousMode = true; this.savedSynchronousNotif = dojo.clone(this.notifqueue.synchronous_notifs); dojo.style(&#39;leftright_page_wrapper&#39;, &#39;visibility&#39;, &#39;hidden&#39;); dojo.style(&#39;loader_mask&#39;, &#39;display&#39;, &#39;block&#39;); dojo.style(&#39;loader_mask&#39;, &#39;opacity&#39;, 1); for (var i in this.notifqueue.synchronous_notifs) { if (this.notifqueue.synchronous_notifs[i] != - 1) { this.notifqueue.synchronous_notifs[i] = 1; } } }},Clicking on this button has the following consequences: setting instantaneousMode = true, which is used in slideTo to reduce the duration to 1, and in various other framework transition function (fadeOut, addToStock, …) displaying the “loader_mask” element on top of everything else reducing synchronous duration of notifications to 1This sounds like a great idea, so why is it still so slow? Let’s use the performance tool to see what is happening:(you can click on a row to have more details about which part of the code is corresponding to that row)Here are the three main bottlenecks that might arises in any games: some notifications seems to take as much time as in normal slow mode there are bunch of setTimeout floating around there are a lot of style recalculationFor experimenting while trying to solve these issues, it was convenient to have an helper function that I could switch on/off easily:isFastMode(){ return this.instantaneousMode; // true / false}That way, returning true would allow to use the normal step-by-step replay while mimicking the fast mode.Improving notificationsThe framework is making all notifications synch timing to 1sec, which sounds good but has two flaws: if you are using non-framework animations, this can break you code as notifications will run one after the other without checking that the animation is over if you are using dynamic synch timing (using this.notifqueue.setSynchronousDuration), then your notification will take the same time as in a normal slow replaySo the first step was to make all the notifications fast-replay-compatible. For instance, we have this notification in Agricola when a player play a card that will zoom on the card, them zoom off to its location before resolving the notification, which is useless in fast mode. So I just add a bypass of the whole flow by checking the value of isFastMode: notif_buyCard(n) { debug(&#39;Notif: buying a card&#39;, n); let card = n.args.card; let duration = 700; let waitingTime = 80000 / this._cardAnimationSpeed; // Create the card if needed, and compute initial location of sliding event let exists = $(card.id); let from = this.computeSlidingAnimationFrom(card, &#39;cards-wrapper-&#39; + card.pId); if (this.isFastMode()) { this.notifqueue.setSynchronousDuration(0); } else { // Zoom on it, then zoom off this.zoomOnCard(card.id, { from, duration }) .then(() =&amp;gt; this.wait(waitingTime)) .then(() =&amp;gt; this.zoomOffCard({ duration })) .then(() =&amp;gt; this.notifqueue.setSynchronousDuration(10)); } ...}I don’t like that much the fact that notification timing are hardcoded to 1 in this mode, so I made it more flexible by allowing the notifications to enforce their synch time if they need to:this._notifications = [ [&#39;revealActionCard&#39;, 1100], [&#39;placeFarmer&#39;, null], [&#39;growChildren&#39;, 1000], ...];setupNotifications() { console.log(this._notifications); this._notifications.forEach((notif) =&amp;gt; { var functionName = &#39;notif_&#39; + notif[0]; let wrapper = (args) =&amp;gt; { let timing = this[functionName](args); if (timing === undefined) { if (notif[1] === undefined) { console.error( &quot;A notification don&#39;t have default timing and didn&#39;t send a timing as return value : &quot; + notif[0], ); return; } // Override default timing by 0 in case of fast replay mode timing = this.isFastMode() ? 0 : notif[1]; } if (timing !== null) { this.notifqueue.setSynchronousDuration(timing); } }; });}Making the flow as asynch as possibleNow let’s take care of these bunch of setTimeouts, which are coming from two main part in my case: sliding animations which have in a setTimeout with duration 1 for the onEnd listener -_-‘ counters????Improve slide functionAll my slidings are usually the attach: true parameter of my slide functions which means: once the animation is over, attach the mobile element to the target and remove absolute positionning. What a waste of resources to do all that in fast-mode where it’s basically the same as just moving directly the node around:slide(mobileElt, targetElt, options = {}) { ... // Mobile elt mobileElt = $(mobileElt); let mobile = mobileElt; // Target elt targetElt = $(targetElt); let targetId = targetElt; let newParent = config.attach ? targetId : $(mobile).parentNode; // Handle fast mode if (this.isFastMode() &amp;amp;&amp;amp; (config.destroy || config.clearPos)) { if (config.destroy) dojo.destroy(mobile); else dojo.place(mobile, targetElt); return new Promise((resolve, reject) =&amp;gt; { resolve(); }); } ...}CountersIn Agricola, we are using a loooot of counters for scores, resources, …Inside notifications, we are using the toValue to have this nice animation while playing the game. But these animations are useless in fast mode!But shouldn’t the framework be handling this as for reducing the duration of slideTo function? Well it probably should, but it’s not doing it….So let’s make our own by copying the existing one (and improve it to handle floating value as well).Instead of creating a dojo component, I just went a dirty way by creating an object on the fly with corresponding methods, please don’t puke while reading this:/** * Own counter implementation that works with fast mode replay */createCounter(id, defaultValue = 0) { if (!$(id)) { console.error(&#39;Counter : element does not exist&#39;, id); return null; } let game = this; let o = { span: $(id), targetValue: 0, currentValue: 0, speed: 100, getValue: function () { return this.targetValue; }, setValue: function (n) { this.currentValue = +n; this.targetValue = +n; this.span.innerHTML = +n; }, toValue: function (n) { if (game.isFastMode()) { this.setValue(n); return; } this.targetValue = +n; if (this.currentValue != n) { this.span.classList.add(&#39;counter_in_progress&#39;); setTimeout(() =&amp;gt; this.makeCounterProgress(), this.speed); } }, incValue: function (n) { let m = +n; this.toValue(this.targetValue + m); }, makeCounterProgress: function () { if (this.currentValue == this.targetValue) { setTimeout(() =&amp;gt; this.span.classList.remove(&#39;counter_in_progress&#39;), this.speed); return; } let step = Math.ceil(Math.abs(this.targetValue - this.currentValue) / 5); this.currentValue += (this.currentValue &amp;lt; this.targetValue ? 1 : -1) * step; this.span.innerHTML = this.currentValue; setTimeout(() =&amp;gt; this.makeCounterProgress(), this.speed); }, }; o.setValue(defaultValue); return o;},This is the new speed after doing all these changes, pretty neat already:Prevent the repaintsWhen looking to the perf tool, the main bottleneck seems to be style calculation, which is normal because we are moving a lot of stuff around. Wait, I’m not actually seeing everything moving around since it’s hidden beside the loading mask, so the browser should do that silently, right ?The answer is: that’s depend what hidden means. If we look back at setModeInstataneous, we can see that the function is doing this change of style of the main container:dojo.style(&#39;leftright_page_wrapper&#39;, &#39;visibility&#39;, &#39;hidden&#39;);Hidding an element with this css property will keep it’s width/height so that means the browser has to recompute the styles to properly updates the width/height of this element, even if you can’t see it!The solution is pretty easy then, just use display:none instead! Actually, we will need a bit more work because the loading screen won’t have the proper height now that the main container is not longer displayed, which can be easily fixed by doing a cleaner loading screen solution:constructor() { ... dojo.place(&#39;loader_mask&#39;, &#39;overall-content&#39;, &#39;before&#39;); dojo.style(&#39;loader_mask&#39;, { height: &#39;100vh&#39;, position: &#39;fixed&#39;, });},// Overwrite this to make display:nonesetModeInstataneous() { if (this.instantaneousMode == false) { this.instantaneousMode = true; dojo.style(&#39;leftright_page_wrapper&#39;, &#39;display&#39;, &#39;none&#39;); dojo.style(&#39;loader_mask&#39;, &#39;display&#39;, &#39;block&#39;); dojo.style(&#39;loader_mask&#39;, &#39;opacity&#39;, 1); }},// Overwrite this to make display:block after fast mode is offunsetModeInstantaneous() { if (this.instantaneousMode) { this.instantaneousMode = false; dojo.style(&#39;leftright_page_wrapper&#39;, &#39;display&#39;, &#39;block&#39;); dojo.style(&#39;loader_mask&#39;, &#39;display&#39;, &#39;none&#39;); }},And now we finally get this much nicer speed:" } ]
